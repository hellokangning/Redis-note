Redis服务器负责与多个客户端建立连接，处理客户端的命令请求，在数据库中保存命令产生的数据，并通过资源管理来维持服务器自身的运转。

# 14.1 命令请求的执行过程

`SET KEY VALUE`命令的执行过程：

1. 客户端向服务器发送命令请求`SET KEY VALUE`。
2. 服务器接收并处理命令请求，在数据库中设置操作，并产生命令回复OK。
3. 服务器将OK发送给客户端。
4. 客户端接收服务器返回的命令OK，并打印给用户。

## 发送命令请求

用户：键入命令请求

客户端：将命令请求转换为协议格式然后发送给服务器

## 读取命令请求

当连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器执行以下操作：

1. 读取套接字协议格式中的命令请求，并将其保存在客户端状态的输入缓冲区里。
2. 对输入缓冲区的命令请求进行分析，提取命令参数及其个数，保存到客户端状态的argv和argc属性。
3. 调用命令执行器，执行指定的命令。

## 命令执行器（1）：查找命令实现

命令执行器要做的第一件事是根据客户端状态的`argv[0]`参数，在命令表（command table）中查找参数指定的命令，并将其保存到客户端状态的`cmd`属性里。

命令表是一个字典，键是命令名字，值是一个`redisCommand`结构。命令表使用的是**大小写无关**的查找算法。

## 命令执行器（2）：执行预备操作

有了执行命令所需的命令实现函数、参数、参数个数，但程序还需要一些预备操作：

- 检查客户端状态的`cmd`指针是否为`NULL`。
- 根据`cmd`属性指向`redisCommand`结构的`arity`属性，检查命令请求的参数个数是否正确。
- 检查客户端是否通过了身份验证，未通过必须使用`AUTH`命令。
- 如果服务器打开了`maxmemory`功能，检查内存占用情况，有需要时进行内存回收。
- 如果上一次`BGSAVE`出错，且服务器打开了`stop-writes-on-bgsave-error`功能，且服务器要执行一个写命令，拒绝执行。
- 如果客户端正在用`SUBSCRIBE`订阅频道，服务器只会执行订阅相关的命令。
- 如果服务器正在进行输入载入，那么客户端发送的命令必须带有1标识才能被执行。
- 如果服务器因为Lua脚本而超时阻塞，那么服务器只会执行客户端发来的`SHUTDOWN nosave`和`SCRIPT KILL`命令。
- 如果客户端正在执行事务，那么服务器只会执行客户端发来的`EXEC`、 `DISCARD`、 `MULTI`、 `WATCH`命令，其余命令进入事务队列。
- 如果服务器打开监视器功能，要将执行的命令和参数等信息发给监视器，其后才真正执行命令。

## 命令执行器（3）：调用命令的实现函数

> client->cmd->proc(client);

相当于执行语句：

> sendCommand(client);

命令回复会保存在输出缓冲区，之后实现函数还会为套接字关联命令回复处理器，将回复返回给客户端。

##  命令执行器（5）：执行后续工作

- 如果开启了慢查询，添加新的日志。
- `redisCommand`结构的`calls`计数器+1。
- 写入AOF缓冲区。
- 同步从服务器。

## 将命令回复发送给客户端

但客户端套接字变为可写时，服务器将输出缓冲区的命令发送给客户端。发送完毕后，清空输出缓冲区。

## 客户端接收并打印命令回复

服务器：回复处理器将协议格式的命令返回给客户端。

客户端：将回复格式化成人类可读的格式，打印。

# 14.2 serverCron函数

