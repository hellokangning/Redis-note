Redis中，用户可以执行`SAVEOF`命令或设置`saveof`选项，让一个服务器去复制（replicate）另一个服务器。被复制的服务器叫做master，对master进行复制的服务器叫做slave。

进行复制中的master和slave应该保存相同的数据，这称作“数据库状态一致”。

## 15.1 旧版复制功能的实现

Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 同步用于将slave的数据库状态更新至master当前所处的数据库状态。
- 命令传播用于master的数据块状态被修改，导致和lsave的数据库状态不一致时，让两者的数据库重回一致状态。

## 同步

复制开始时，slave会先执行同步操作，步骤如下：

- slave对master发送`SYNC`命令
- master收到`SYNC`执行`BGSAVE`，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
- master的`BGSAVE`执行完毕后，将生成的RDB文件发送给slave，slave接收并载入这个RDB，更新自己的数据库状态
- master将记录在缓冲区中的所有写命令发送给slave，后者执行这些操作，再次更新自己的数据库状态

## 命令传播

同步完成后，主从服务器的一致状态仍有可能改变，每当master执行写命令时，主从服务器的状态就会不一致。为此，master执行写命令，并将其发送给slave一并执行。

# 15.2 旧版复制功能的缺陷

Redis的复制可以分为两种情况：

- 初次复制：slave没有复制过，或者slave要复制的master和上一次复制的master不同。
- 断线后重复制：处于命令传播阶段的master和slave中断了复制，但重连后，slave继续复制master。

对于初次复制，旧版复制功能可以很好完成。但是断线后复制，效率却很低，因为重连后会浪费一次`SYNC`操作。

# 15.3 新版复制功能的实现

为了解决旧版复制功能在断线后的低效问题，Redis从2.8之后，使用`PSYNC`代替`SYNC`执行复制时的同步操作。`PSYNC`具有完整重同步（full resynchronization)和部分重同步（partial resynchronization）两种模式：

- 完整重同步用于处理初次复制，执行步骤和`SYNC`命令基本一样。
- 部分重同步用于处理断线后重复制，重连后，如果条件允许，master可以将断开期间的谢明令发送给slave执行。

# 15.4 部分重同步的实现

部分重同步功能有三个部分组成：

- master和slave的复制偏移量（replication offset）
- master的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

## 复制偏移量

master和slave分别维护一个复制偏移量：

- master每次向slave传播N个字节的数据时，就将自己的复制偏移量+N。
- slave每次收到master的N个字节数据时，就将自己的复制偏移量+N。

对比两者的复制偏移量，就知道它们是否处于一致状态。

## 复制积压缓冲区

复制积压缓冲区是master维护的一个固定长度的FIFO队列，默认大小为1MB。当服务器进行命令传播时，不仅会将命令发送给所有slave，还会入队到积压缓冲区。因此，积压缓冲区保存了最近被传播的写命令，且为队列中的每个字节记录相应的复制偏移量。

slave重连上master时，slave通过`PSYNC`将自己的复制偏移量offset发送给master，master会根据这个offset决定slave执行何种同步操作：

- 如果offset之后的数据仍在复制积压缓冲区中，执行部分重同步操作。
- 否则，执行完整重同步操作。

## 服务器运行ID

部分重同步还要用到服务器运行ID，主从服务器都有自己的ID。初次复制时，master将自己的ID传给slave，后者将其保存。

断线重连后，slave向当前连接的master发送之前保存的ID：

- master发现接收的ID和自己的相同，那么说明断线之前复制的就是自己，继续执行部分重同步。
- 如果不同，完整重同步啦！

# 15.5 PSYNC命令的实现

