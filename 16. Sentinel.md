Sentinel（哨兵）是Redis的高可用性解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个master以及属下的所有slave。Sentinel在被监视的master下线后，自动将其属下的某个slave升级为新的master，然后由新的master继续处理命令请求。

# 16.1 启动并初始化Sentinel

启动一个Sentinel可以使用命令：

> redis-sentinel sentinel.conf

或者

> redis-server sentnel.conf —sentinel

当一个Sentinel启动时，会执行以下几步：

1. 初始化服务器
2. 将普通Redis服务器使用的代码替换成Sentinel专用代码
3. 初始化Sentinel状态
4. 根据配置文件，初始化监视的master列表
5. 创建与master的网络连接

## 初始化服务器

Sentinel本质上是一个运行在特殊模式下的Redis服务器，它的初始化过程与普通Redis服务器并不相同：

| 功能                                   | Sentinel使用情况                             |
| ------------------------------------ | ---------------------------------------- |
| 数据库和键值对方面的命令：`SET`, `DEL`, `FLUSHDB` | 不使用                                      |
| 事务命令                                 | 不使用                                      |
| 脚本命令                                 | 不使用                                      |
| RDB和AOF持久化                           | 不使用                                      |
| 复制命令                                 | Sentinel内部使用，客户端不可用                      |
| 发布、订阅命令                              | 订阅命令可在Sentinel内部和客户端使用，发布命令只能在Sentinel内部使用 |
| 文件事件处理器（发送命令请求，处理命令回复）               | Sentinel内部使用                             |
| 时间事件处理器                              | Sentinel内部使用，`serverCron`会用`sentinel.c/sentinelTimer`函数 |

## 使用Sentinel专用代码

将一部分普通Redis服务器的代码替换为Sentinel专用代码，比如端口号，命令表。

## 初始化Sentinel状态

接下来，服务器会初始化一个`sentinel.c/sentinelState`结构，它保存了服务器有关Sentinel的状态：

```c
struct sentinelState {
  // 当前纪元，用于实现故障转移
  uint64_t current_epoch;
  
  // 保存了所有被监视的master，键是master名字，值是指向 sentinelRedisInstance 结构的指针
  dict *masters;
  
  // 是否进入TILT模式
  int tilt;
  
  // 目前正在执行的脚本数量
  int runing_scripts;
  
  // 进入TILT模式的时间
  mstime_t tilt_start_time;
  
  // 最后一次执行时间处理器的时间
  mstime_t previous_time;
  
  // FIFO队列，包含所有需要执行的用户脚本
  list *scripts_queue;
} sentinel;
```

## 初始化Sentinel状态的masters属性

sentinelRedisInstance结构代表一个被监视的Redis服务器实例，可以是master、slave、或者另一个Sentinel。

```c
typedef struct sentinelRedisInstance {
  // 标识符，记录了实例的类型，及其当前状态
  int flags;
  
  // 实例的名字，master的名字由用户配置，slave和Sentinel的名字自动配置
  // 格式为 ip: port
  char *name;
  
  // 实例的运行ID
  char *runid;
  
  // 配置计院，用于实现故障转移
  uint64_t config_epoch;
  
  // 实例的地址
  sentinelAddr *addr;
  
  // SENTINEL down-after-milliseconds选项设定的值
  // 实例无响应多少毫秒后才会判断为主观下线(subjectively down)
  mstime_t down_after_periods;
  
  // SENTINEL monitor <master-name> <IP> <port> <quorum> 选项的quorum参数
  // 判断这个实例是否为客观下线(objectively down)所需的支持投票数量
  int quorum;
  
  // SENTINEL parallel-sycs <master-name> <number>选项的值
  // 在执行故障转移时，可以同时对新的master进行同步的slave数量
  int parallel_syncs;
  
  // SENTINEL failover-timeout <master-name> <ms>选项的值
  // 判断故障转移状态的最大时限
  mstime_t failover_timeout;
} sentinelRedisInstance;
```

`sentinelRedisInstance.addr`指向一个`sentinel.c/sentinelAddr`结构，它保存着实例的IP地址和端口号：

```c
typedef struct sentinelAddr {
  char *ip;
  int port;
} sentinelAddr;
```

## 创建与master的网络连接

连接建立后，Sentinel将成为master的客户端，可以向其发送命令。对于被监视的master来说，Sentinel会创建两个异步网络连接：

- 命令连接，用于发送和接收命令。
- 订阅连接。用于订阅master的`__sentinel_:hello`频道。

# 16.2 获取master信息

Sentinel以默认10秒一次的频率，向master发送`INFO`命令，获取其当前信息：

- master本身的信息，包括运行ID、role等。据此，Sentinel更新master实例的结构。
- master的slave信息。据此，Sentinel更新master实例的slaves字典。

# 16.3 获取slave信息

Sentinel发现master有新的slave时，除了会为这个slave创建相应的实例结构外，还会创建到它的命令连接和订阅连接。

通过命令连接，Sentinel会向slave每10秒发送一次`INFO`命令，根据回复更新slave的实例结构：

- slave的运行ID
- slave的角色role
- master的地址和端口
- 主从的连接状态
- slave的优先级
- slave的复制偏移量

# 16.4 向master和slave发送信息

