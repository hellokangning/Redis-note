Redis集群是分布式的数据库方案，通过分片（sharing）来进行数据共享，并提供复制或故障转移功能。

# 17.1 节点

一个Redis集群通常由多个节点（node）组成。开始时每个node都是独立的，要将其连接起来：

> CLUSTER MEET <ip> <port>

## 启动节点

一个节点就是运行在集群模式下的Redis服务器，根据`cluster-endabled`配置选项是否为yed来决定是否开启集群模式。

节点在集群模式下会继续使用单机模式的组件，如：

- 文件事件处理器
- 时间事件处理器
- 使用数据库来保存键值对数据
- RDB和AOF持久化
- 发布与订阅
- 复制模块
- Lua脚本

节点会继续使用`redisServer`结构保存服务器的状态，`redisClient`结构保存客户端的状态，集群模式下的数据，保存在`cluster.h/clusterNode`、`cluster.h/clusterLink`、`cluster.h/clusterState`结构中。

## 集群数据结构

`cluster.h/clusterNode`保存了一个节点的当前状态，如节点的创建时间、名字、配置纪元、IP和端口等。每个节点都有一个自己的`clusterNode`结构，并为集群中的其他节点创建一个相应的`clusterNode`结构。`clusterNode`结构的`link`属性是一个`clusterLink`结构，保存了连接节点所需的有关信息，如套接字、缓冲区。

每个节点都有一个`clusterState`，记录了当前节点所在集群的状态。

```c
struct clusterNode {
  // 创建节点的时间
  mstime_t ctime;
  
  // 节点的名字，40个十六进制字符串
  char name[REDIS_CLUSTER_NAMELEN];
  
  // 节点标识，记录节点的角色(主从)、状态(在线或下线)
  int flags;
  
  // 当前的配置纪元
  uint64_t configEpoch;
  
 char ip[REDIS_IP_STR_LEN];
 int port;
  
  // 保存连接节点所需的有关信息
  clusterLink *link;
};

typedef struct clusterLink {
  // 连接的创立时间
  mstime_t ctime;
  
  // TCP 套接字描述符
  itn fd;
  
  // 输出缓冲区
  sds sndbuf;
  
  // 输入缓冲区
  sds recvbuf;
  
  // 与这个连接相关联的节点，没有就为NULL
  struct clusterNode *node;
} clusterLink;

typedef struct clusterState {
  // 指向当前节点的指针
  clusterNode *myself;
  
  // 集群当前的配置纪元，用于故障转移
  uint64_t currentEpoch;
  
  // 集群当前的状态：在线还是下线
  int state;
  
  // 集群中至少处理着一个槽的节点的数量
  int size;
  
  // 集群节点的名单，包括myself，键为节点的名字，值为节点对应的clusterNode结构
  dict *nodes;
} clusterState;
```

## CLUSTER MEET命令的实现

通过向节点A发送`CLUSTER MEET`命令，客户端可以让接受命令的节点A将另一个节点B接入到A所在的集群中。

收到`CLUSTER MEET`命令的节点A，会进行以下操作：

1. 为节点B创建一个`clusterNode`结构，并将该结构添加到自己的`clusterState.nodes`字典。
2. 节点A根据`CLUSTER MEET`命令的IP和端口，先节点B发送`MEET`消息。
3. 节点B收到`MEET`消息，为节点A创建一个`clusterNode`结构，并加入字典。
4. 节点B回给节点A一条`PONG`消息。
5. 节点A收到`PONG`，知道节点B已经接收了自己的`MEET`消息。
6. 节点A向节点B返回一条`PING`消息。
7. 节点B收到`PING`之后，双方握手完成。

![](img/chap17/img0.png)

# 17.2 槽指派

Redis集群通过分片的方式保存数据库中的键值对：集群中的整个数据库被分为16384个槽（slot），数据库中的每个键都属于其中的一个，集群中的每个节点可以处理0个或最多16384个槽。

当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok），如果任何一个槽都没有得到处理，就处于下线状态（fail）。

`CLUSTER MEET`只是将节点连接起来，集群仍处于下线状态，通过向节点发送`CLUSTER ADDSLOTS`，可以为一个或多个槽指派（assign）给节点负责。

> CLUSTER ADDSLOTS <slot> [slot ...]

## 记录节点的槽指派信息

```c
struct clusterNode {
  unsigned char slots[16384/8];
  int numslots;
};
```



# 导航

[目录](README.md)

上一章：[16. Sentinel](16. Sentinel.md)

下一章：
