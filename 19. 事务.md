Redis通过`MULTI`、`EXEC`、`WATCH`等命令实现事务（transaction）功能。事务提供一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。在事务执行期间，服务器不会中断事务去执行其他客户端的命令请求。

事务以`MULTI`开始，接着是多个命令放入事务之中，最后由`EXEC`将这个事务提交（commit）到服务器执行。

# 19.1 事务的实现

一个事务从开始到结束经历三个阶段：

1. 事务开始
2. 命令入队
3. 事务执行

## 事务开始

`MULTI`命令标志着事务的开始，它将客户端从非事务状态切换到事务状态，即打开客户端状态的`flags`属性的`REDIS_MULTI`标识：

```python
def MULTI():
    client.flags |= REDIS_MULTI
    replyOK()
```

## 命令入队

客户端切换到事务状态后，服务器会根据不同的命令执行不同的操作：

- `EXEC`、`DISCARD`、`WATCH`、`MULTI`其中一个，服务器立即执行该命令。
- 否则，服务器将命令放入一个事务队列，然后向客户端返回`QUEUED`回复。

## 事务队列

每个Redis客户端都有自己的事务状态，保存在客户端状态的`mstate`属性中：

```c
typedef struct redisClient {
	multiState mstate;
} redisClient;

typedef struct multiState {
 	// 事务队列，FIFO顺序
	multiCmd *commands;
  
  	// 已入队命令计数
  	int count;
} multiState;

typedef struct multiCmd {
  	// 参数
  	robj **argv;
  
   // 参数数量
   int argc;
  
   // 命令指正
   struct redisCommand *cmd;
} multiCmd;
```

## 执行事务

服务器收到`EXEC`命令后，会遍历客户端的事务列表，执行其中的所有命令。最后将执行所得的结果返回给客户端。

```python
def EXEC():
    # 创建空白的回复队列
    reply_queue = []
    
    # 遍历事务列表中的每个项
    for argv, argc, cmd in client.mstate.commands:
        
        # 执行命令
        reply = execute_command(cmd, argv, argc)
        reply_quque.append(reply)
     
    # 移除 REDIS_MULTI 标识
    client.flags &= ~REDIS_MULTI
    
    # 清空客户端的事务状态，清零计数器，释放事务队列
    client.mstate.count = 0
    release_transaction_queue(client.mstate.commands)
    
    send_reply_to_client(client, reply_queue)
```

# 19.2 WATCH 命令的实现

`WATCH`命令是个乐观锁，它可以再`EXEC`执行之前，监视任意数量的数据库键，并在`EXEC`执行时，检查被监视的键是否至少有一个已经被修改过了。如果是，服务器将拒绝执行事务，并返回客户端事务执行失败的空回复。

## 使用 WATCH 命令监视数据库键

每个Redis数据库都保存了一个`watched_keys`字典，键是某个被`WATCH`的数据库键，值是一个链表，记录了所有监视该键的客户端：

```c
typedef struct redisDb {
  dict *watched_keys;
} redisDb;
```

## 监视机制的触发

所有对数据库进行修改的命令，执行之后都会调用`multi.h/touchWatchKey`函数对`watched_keys`字典进行检查。如果被监视的键被修改，那么打开监视该键的客户端的`REDIS_DIRTY_CAS`标识，表示该客户端的事务安全性已遭破坏。

## 判断事务是否安全

服务器收到`EXEC`命令后，根据这个客户端是否打开了`REDIS_DIRTY_CAS`标识来决定是否执行事务。

