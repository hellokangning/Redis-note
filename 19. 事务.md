Redis通过`MULTI`、`EXEC`、`WATCH`等命令实现事务（transaction）功能。事务提供一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。在事务执行期间，服务器不会中断事务去执行其他客户端的命令请求。

事务以`MULTI`开始，接着是多个命令放入事务之中，最后由`EXEC`将这个事务提交（commit）到服务器执行。

# 19.1 事务的实现

一个事务从开始到结束经历三个阶段：

1. 事务开始
2. 命令入队
3. 事务执行

## 事务开始

`MULTI`命令标志着事务的开始，它将客户端从非事务状态切换到事务状态，即打开客户端状态的`flags`属性的`REDIS_MULTI`标识：

```python
def MULTI():
    client.flags |= REDIS_MULTI
    replyOK()
```

## 命令入队

客户端切换到事务状态后，服务器会根据不同的命令执行不同的操作：

- `EXEC`、`DISCARD`、`WATCH`、`MULTI`其中一个，服务器立即执行该命令。
- 否则，服务器将命令放入一个事务队列，然后向客户端返回`QUEUED`回复。

## 事务队列

每个Redis客户端都有自己的事务状态，保存在客户端状态的`mstate`属性中：

```c
typedef struct redisClient {
	multiState mstate;
} redisClient;

typedef struct multiState {
 	// 事务队列，FIFO顺序
	multiCmd *commands;
  
  	// 已入队命令计数
  	int count;
} multiState;

typedef struct multiCmd {
  	// 参数
  	robj **argv;
  
   // 参数数量
   int argc;
  
   // 命令指正
   struct redisCommand *cmd;
} multiCmd;
```

## 执行事务

服务器收到`EXEC`命令后，会遍历客户端的事务列表，执行其中的所有命令。最后将执行所得的结果返回给客户端。

```python
def EXEC():
    # 创建空白的回复队列
    reply_queue = []
    
    # 遍历事务列表中的每个项
    for argv, argc, cmd in client.mstate.commands:
        
        # 执行命令
        reply = execute_command(cmd, argv, argc)
        reply_quque.append(reply)
     
    # 移除 REDIS_MULTI 标识
    client.flags &= ~REDIS_MULTI
    
    # 清空客户端的事务状态，清零计数器，释放事务队列
    client.mstate.count = 0
    release_transaction_queue(client.mstate.commands)
    
    send_reply_to_client(client, reply_queue)
```

# 19.2 WATCH 命令的实现

