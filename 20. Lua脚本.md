Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器原子地执行多个Redis命令。

`EVAL`命令可以直接对输入的脚本进行求值：

> EVAL "return 'hello world'" 0
>
> "hello world"

`EVALSHA`命令可以根据脚本的SHA1校验和来对脚本进行求值，但这个命令要求校验和对应的脚本至少被`EVAL`命令执行过一次，或者被`SCRIPT LOAD`命令载入过。

# 20.1 创建并修改Lua环境

Redis服务器创建并修改Lua环境的整个过程有以下步骤：

1. 创建一个基础的Lua环境
2. 载入多个函数库到Lua环境
3. 创建全局表格`redis`，表格包含了对Redis进行操作的函数，如`redis.call`
4. 使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数
5. 创建排序辅助函数
6. 创建`redis.pcall`函数的错误报告辅助函数，这个函数可以提供更详细的出错信息
7. 对Lua环境中的全局变量进行保护，防止用户在执行Lua脚本时添加额外的全局变量
8. 将完成修改的Lua环境保存到服务器状态的`lua`属性中，等待服务器传来的Lua脚本

## 创建Lua环境

服务器调用Lua的C API函数`lua_open`，创建一个新的Lua环境。

## 载入函数库

- 基础库（base library）：包含Lua的核心函数，如`assert`、`error`等。为了防止用户从外部文件引入不安全的代码，`loadfile`函数被删除。
- 表格库（table library）
- 字符串库（string library）
- 数学库（math library）
- 调试库（debug library）
- Lua CJSON库
- Struct库：用于Lua值和C结构的转换
- Lua cmsgpack库：处理MessagePack格式的数据

## 创建redis全局表格

`redis`表格包含以下函数：

- 用于执行Redis命令的`redis.call`和`redis.pcall`
- 用于记录日志的`redis.log`
- 用于计算SHA1校验和的`redis.sha1hex`
- 用于返回错误信息的`redis.error_repyl`和`redis.status_reply`

## 使用Redis自制的随机函数来替换Lua原有的随机函数

Redis服务器要求传入的Lua脚本都是纯函数（pure function）。

Redis用自制的随机函数替换了原有的`math.random`和`math.randomseed`函数，自制函数有如下特征：

- 对于相同的seed，`math.random`总是相同的随机数序列。
- 对除非在脚本中使用`math.randsomseed`显式修改seed，否则每次运行脚本时，Lua环境都是用固定的`math.randomseed(0)`来初始化seed。

## 创建排序辅助函数

当Lua脚本执行完一个不确定性的命令后，会使用`__redis__compare_helper`函数作为对比函数，自动调用`table.sort`函数对命令的返回值排序，以保证相同的数据集总是产生相同是输出。

## 创建 redis.pcall 函数的错误报告辅助函数

Redis服务器为Lua环境创建一个名为`__redis__err__handler`的错误处理函数。当脚本调用`redis.pcall`执行Redis命令，且执行的命令出现错误，`__redis__err__handler`函数会打印出错代码的来源和行数。

## 保护Lua的全局环境

确保传入服务器的脚本不会因为忘记使用`local`关键字而将额外的全局变量添加到Lua环境。

## 将Lua环境保存到服务器状态的lua属性中

这一步，服务器将Lua环境与服务器状态的`lua`属性关联起来。

因为Redis使用串行化的方式来执行命令，所以任意时刻，最多只会有一个脚本能够被放入Lua环境执行。因此，整个Redis服务器只需要一个Lua环境即可。

# 20.2 Lua环境协作组件

