Redis并没有使用SDS、双端链表、字典、压缩列表、整数集合来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

通过这五种类型的对象，Redis可以在执行命令之前，根据对象的类型判断一个对象是否执行给定的命令。使用对象的好处是，可以针对不同的场景，为对象设置多种不同的数据结构的实现，从而优化使用效率。

除此之外，Redis还实现了引用计数的内存回收机制。当程序不再需要某个对象的时候，它所占用的内存会被自动释放。另外，Redis还用引用计数实现了对象共享，让多个数据库键共享同一个对象来节约内存。

最后，Redis的对象带有访问时间记录信息，空转时长较大的键可能被优先删除。

# 8.1 对象的类型和编码

Redis使用对象来表示数据库中的键和值。创建一个新键值对时，至少会创建两个对象，一个对象用作键，一个对象用作值。每个对象都由一个redisObject结构表示： 

```c
typedef struct redisObject {
  unsigned type: 4; // 类型
  unsigned encoding: 4; // 编码
  void *ptr; // 指向底层实现数据结构的指针
  // ...
} robj;
```

 ## 类型

对象的type记录了对象的类型，它的值可以使

| type常量        | 对象的名称  |
| ------------- | ------ |
| REDIS\_STRING | 字符串对象  |
| REDIS\_LIST   | 列表对象   |
| REDIS\_HASH   | 哈希对象   |
| REDIS\_SET    | 集合对象   |
| REDIS\_ZSET   | 有序集合对象 |

键总是一个字符串对象，值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。

但数据库执行TYPE命令时，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。

## 编码和底层实现

对象的ptr指向对象的底层实现数据结构，而这些数据结构由对象的encoding决定，它可以是：

| encoding常量                  | 对应的底层数据结构    |
| --------------------------- | ------------ |
| REDIS\_ENCODING\_INT        | long类型的整数    |
| REDIS\_ENCODING\_EMBSTR     | embstr编码的SDS |
| REDIS\_ENCODING\_RAW        | SDS          |
| REDIS\_ENCODING\_HT         | 字典           |
| REDIS\_ENCODING\_LINKEDLIST | 双端链表         |
| REDIS\_ENCODING\_ZIPLIST    | 压缩列表         |
| REDIS\_ENCODING\_INTSET     | 整数集合         |
| REDIS\_ENCODING\_SKIPLIST   | 跳跃表和字典       |

每种类型的对象至少使用了两种编码。

使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。

# 8.2 字符串对象

