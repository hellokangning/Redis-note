Redis并没有使用SDS、双端链表、字典、压缩列表、整数集合来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

通过这五种类型的对象，Redis可以在执行命令之前，根据对象的类型判断一个对象是否执行给定的命令。使用对象的好处是，可以针对不同的场景，为对象设置多种不同的数据结构的实现，从而优化使用效率。

除此之外，Redis还实现了引用计数的内存回收机制。当程序不再需要某个对象的时候，它所占用的内存会被自动释放。另外，Redis还用引用计数实现了对象共享，让多个数据库键共享同一个对象来节约内存。

最后，Redis的对象带有访问时间记录信息，空转时长较大的键可能被优先删除。

# 8.1 对象的类型和编码

Redis使用对象来表示数据库中的键和值。创建一个新键值对时，至少会创建两个对象，一个对象用作键，一个对象用作值。每个对象都由一个redisObject结构表示： 

```c
typedef struct redisObject {
  unsigned type: 4; // 类型
  unsigned encoding: 4; // 编码
  void *ptr; // 指向底层实现数据结构的指针
  // ...
} robj;
```

 ## 类型

对象的type记录了对象的类型，它的值可以使

| type常量        | 对象的名称  |
| ------------- | ------ |
| REDIS\_STRING | 字符串对象  |
| REDIS\_LIST   | 列表对象   |
| REDIS\_HASH   | 哈希对象   |
| REDIS\_SET    | 集合对象   |
| REDIS\_ZSET   | 有序集合对象 |

键总是一个字符串对象，值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。

但数据库执行TYPE命令时，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。

## 编码和底层实现

对象的ptr指向对象的底层实现数据结构，而这些数据结构由对象的encoding决定，它可以是：

| encoding常量                  | 对应的底层数据结构    |
| --------------------------- | ------------ |
| REDIS\_ENCODING\_INT        | long类型的整数    |
| REDIS\_ENCODING\_EMBSTR     | embstr编码的SDS |
| REDIS\_ENCODING\_RAW        | SDS          |
| REDIS\_ENCODING\_HT         | 字典           |
| REDIS\_ENCODING\_LINKEDLIST | 双端链表         |
| REDIS\_ENCODING\_ZIPLIST    | 压缩列表         |
| REDIS\_ENCODING\_INTSET     | 整数集合         |
| REDIS\_ENCODING\_SKIPLIST   | 跳跃表和字典       |

每种类型的对象至少使用了两种编码。

使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。

# 8.2 字符串对象

字符串对象的编码可以使int、raw或embstr。

1. 如果字符串对象保存的是整数值，且可以用long类型表示，那么字符串对象会将整数值保存在ptr中（将void* 转换成 long），并将编码设置为int。
2. 如果字符串对象保存到是一个字符串值，且长度大于32字节，那么字符串对象使用SDS来保存这个字符串值，并将编码设置为raw。
3. 如果字符串对象保存到是一个字符串值，且长度小于等于32字节，那么字符串对象使用embstr编码的方式来存储这个字符串值。

embstr编码是专门用来保存短字符串的优化方式。和raw编码一样，都是用redisObject结构和sdshdr结构来表示字符串对象，但raw会调用两次内存分配函数分别创建redisObject结构和sdshdr结构，而embstr则通过一次内存分配一块连续空间，依次包含两个结构：

| redisObject                    | sdshdr             |
| ------------------------------ | ------------------ |
| type \| encoding \| ptr \| ... | free \| len \| buf |

embstr的好处：

1. 内存分配次数降为一次。
2. 释放字符串对象只要一次内存释放函数。
3. 因为内存连续，可以更好地利用缓存。

PS. 用`long double`类型表示的浮点数在Redis中也是作为字符串值存储的。程序会先将浮点数转成字符串值，然后再保存转换的字符串值。

## 编码的转换

int编码和embstr编码的字符串对象可以被转换为raw编码的字符串对象。

1. 对int编码的字符串对象执行一些命令，可使其不再是整数值，而是字符串值，那么编码也就变为raw了。如APPEND。
2. 对embstr编码的字符串，执行修改命令，也会变成raw对象。如APPEND。

## 字符串命令的实现

用于字符串键的所有命令都是针对字符串对象来构建的。

| 命令         | int编码的实现方法                               | embstr编码的实现方法                            | raw编码的实现方法                               |
| ---------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| SET        | int编码保存值                                 | embstr编码保存值                              | raw编码保存值                                 |
| GET        | 拷贝对象所保存的整数值，将这个拷贝转换为字符串值，然后向客户端返回这个字符串值  | 直接向客户端返回字符串值                             | 直接向客户端返回字符串值                             |
| APPEND     | 将对象转换为raw编码，然后按raw方式执行此操作                | 将对象转换为raw编码，然后按raw方式执行此操作                | 调用sdscatlen函数，将给定字符串追加到现有字符串的末尾          |
| INCBYFLOAT | 取出整数值并将其转换为long double的浮点数，对这个浮点数进行加法计算，然后将结果保存起来 | 取出整数值并将其转换为long double的浮点数，对这个浮点数进行加法计算，然后将结果保存起来。如果字符串值不能被转换为浮点数，那么客户端会报错 | 取出整数值并将其转换为long double的浮点数，对这个浮点数进行加法计算，然后将结果保存起来。如果字符串值不能被转换为浮点数，那么客户端会报错 |
| INCBY      | 对整数值进行加法计算，得出的结果作为整数被保存起来                | 不能执行此命令，客户端报错                            | 不能执行此命令，客户端报错                            |
| DECBY      | 对整数值进行减法计算，得出的结果作为整数被保存起来                | 不能执行此命令，客户端报错                            | 不能执行此命令，客户端报错                            |
| STRLEN     | 拷贝对象保存的整数值，将这个拷贝转换为字符串值，计算并返回这个字符串值的长度   | 调用sdslen函数，返回字符串的长度                      | 调用sdslen函数，返回字符串的长度                      |
| SETRANGE   | 将对象转换为raw编码，然后按raw方式执行此命令                | 将对象转换为raw编码，然后按raw方式执行此命令                | 将字符串特定索引上的值设置为给定的字符                      |
| GETRANGE   | 拷贝对象保存的整数值，将这个拷贝转换为字符串，然后取出返回字符串指定索引上的字符 | 直接取出并返回给定索引上的字符                          | 直接取出并返回给定索引上的字符                          |

# 8.3 列表对象

列表对象的编码是ziplist或linkedlist。

使用ziplist时，每个压缩列表的节点保存了一个列表元素。使用linkedlist时，每个链表节点保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。（字符串对象是Redis五种类型的对象中唯一一种会被嵌套的对象。）

## 编码转换

当列表对象同时满足以下两个条件时，使用ziplist编码：

1. 保存的字符串对象的长度都小于64字节。
2. 保存的元素数量小于512个。

否则就是用linkedlist编码。

## 列表命令的实现

| 命令      | ziplist编码的实现                             | linkedlist编码的实现                          |
| ------- | ---------------------------------------- | ---------------------------------------- |
| LPUSH   | 调用ziplistPush函数，将新元素压入表头                 | 调用listAddNodeHead函数，将新元素压入表头             |
| RPUSH   | 调用ziplistPush函数，将新元素压入表尾                 | 调用listAddNodeTail函数，将新元素压入表尾             |
| LPOP    | 调用ziplistIndex定位表头节点，返回节点保存的元素后，调用ziplistDelete删除表头结点 | 调用lsitFrist定位表头节点，返回节点保存的元素后，调用listDelNode删除表头结点 |
| RPOP    | 调用ziplistIndex定位表尾节点，返回节点保存的元素后，调用ziplistDelete删除表尾结点 | 调用listLast定位表尾节点，返回节点保存的元素后，调用listDelNode删除表尾结点 |
| LINDEX  | 调用ziplistIndex                           | 调用listIndex                              |
| LLEN    | 调用ziplistLen                             | 调用listLength                             |
| LINSERT | 插入新节点到表头或表尾时，使用ziplistPush；其他位置使用ziplistInsert | 调用listInsertNode                         |
| LREM    | 遍历节点，调用ziplistDelete删除包含给定元素的节点          | 遍历节点，调用listDelNode删除包含给定元素的节点            |
| LTRIM   | 调用ziplistDeleteRange函数删除不再指定索引范围内的节点     | 遍历节点，调用listDelNode                       |
| LSET    | 调用ziplistDelete，先删除给定索引上的节点，然后调用ziplistInsert插入新节点 | 调用listIndex函数，定位给定索引上的节点，然后通过赋值操作更新节点的值  |

# 8.4 哈希对象

